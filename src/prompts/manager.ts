import type { PromptTracking } from '../util';
import {
  __autogeneratedTemplatePathToTemplate,
  type __AutogeneratedTemplatePathToParameters,
} from './autogenerated';

export class PromptTemplateManager {
  // We keep track of the builders in test environments so we can access their snapshots
  private builders: Record<string, PromptBuilder> = {};

  /**
   * Creates a new builder instance for composing prompt(s) to be sent to an LLM model.
   *
   * @param promptTrackingId The tracking ID for the prompt(s) being built by this builder. This should remain constant over time, as
   * it is used to track how the prompt(s) change over time. This identifier is used to identify the prompt(s) in the Autoblocks UI.
   * @returns TemplateBuilder
   */
  makeBuilder(promptTrackingId: string) {
    const builder = new PromptBuilder({
      trackingId: promptTrackingId,
      templates: __autogeneratedTemplatePathToTemplate,
    });

    if (process.env.NODE_ENV === 'test') {
      this.builders[promptTrackingId] = builder;
    }

    return builder;
  }

  snapshots(promptTrackingId: string): string[] {
    const builder = this.builders[promptTrackingId];

    if (!builder) {
      return [];
    }

    // We assume snapshots are only accessed once.
    // This also allows users to make multiple snapshot
    // assertions for the same promptTrackingId over
    // many tests.
    delete this.builders[promptTrackingId];

    return builder.snapshots();
  }
}

export class PromptBuilder {
  private readonly trackingId: string;
  private readonly templates: Record<string, string>;

  // Keep track of which templates were used during the lifetime of the builder.
  private templatesUsed: Record<string, string>;

  // Keep track of the rendered templates for snapshot testing.
  private templatesRendered: string[];

  constructor(args: { trackingId: string; templates: Record<string, string> }) {
    this.trackingId = args.trackingId;
    this.templates = args.templates;
    this.templatesUsed = {};
    this.templatesRendered = [];
  }

  build<Path extends keyof __AutogeneratedTemplatePathToParameters>(
    path: Path,
    params: __AutogeneratedTemplatePathToParameters[Path],
  ): string {
    const template = this.templates[path];

    if (!template) {
      throw new Error(`No template found for path ${path}`);
    }

    let rendered = template;

    Object.entries(params).forEach(([key, value]) => {
      rendered = rendered.replace(`\${${key}}`, `${value}`);
    });

    // Record that the template was used
    this.templatesUsed[path] = template;

    // Record the rendered template in test environments
    if (process.env.NODE_ENV === 'test') {
      this.templatesRendered.push(rendered);
    }

    return rendered;
  }

  /**
   * Creates a prompt tracking object that will be sent along with Autoblocks events
   * to track which templates were used.
   */
  usage(): PromptTracking {
    const templates = Object.entries(this.templatesUsed).map(
      ([id, template]) => {
        return { id, template };
      },
    );

    return {
      id: this.trackingId,
      templates: templates,
    };
  }

  /**
   * Intended to be used with Jest snapshot testing.
   *
   * This will allow you to easily snapshot the rendered templates
   * so that your code reviews involve both the code changes and the
   * changes to the rendered templates.
   *
   * See https://jestjs.io/docs/snapshot-testing
   *
   * Example:
   *
   * const builder = promptManager.makeBuilder('my-tracking-id');
   *
   * const response = await openai.chat.completions.create({
   *   messages: [
   *     {
   *      role: 'system',
   *      content: builder.build('feature-a/system', {
   *        languageRequirement: builder.build('common/language', {
   *        language: 'Spanish',
   *      }),
   *     },
   *     {
   *      role: 'user',
   *      content: builder.build('feature-a/user', {
   *        name: 'Adam',
   *      }),
   *     },
   *   ],
   *   model: 'gpt-3.5-turbo',
   * });
   *
   * builder.snapshots().forEach((snapshot) => {
   *   expect(snapshot).toMatchSnapshot();
   * });
   */
  snapshots(): string[] {
    return this.templatesRendered;
  }
}
