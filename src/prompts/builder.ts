import type { PromptTracking } from '../util';
import {
  __autogenerated__TemplatePathToTemplate,
  type __Autogenerated__TemplatePathToParameters,
  type __Autogenerated__TemplatePathsWithNoPlaceholders,
} from './autogenerated';

export class AutoblocksPromptBuilder {
  // An identifier for this prompt(s) building session.
  private readonly trackingId: string;

  // Keep track of which templates were used during the lifetime of the builder.
  private templatesUsed: Record<string, string>;

  // Keep track of the rendered templates for snapshot testing.
  private templatesRendered: string[];

  constructor(promptTrackingId: string) {
    this.trackingId = promptTrackingId;
    this.templatesUsed = {};
    this.templatesRendered = [];
  }

  build(
    path: keyof __Autogenerated__TemplatePathsWithNoPlaceholders,
    params?: never,
  ): string;
  build<Path extends keyof __Autogenerated__TemplatePathToParameters>(
    path: Path,
    params: __Autogenerated__TemplatePathToParameters[Path],
  ): string;
  build(path: string, params?: unknown): string {
    const template = __autogenerated__TemplatePathToTemplate[path];

    if (!template) {
      throw new Error(`No template found for path: ${path}`);
    }

    let rendered = template;

    for (const [key, value] of Object.entries(params ?? {})) {
      const re = new RegExp(`\\{\\{\s*${key}\s*\\}\\}`, 'g');
      rendered = rendered.replace(re, `${value}`);
    }

    // Record that the template was used
    this.templatesUsed[path] = template;

    // Record the rendered template in test environments
    if (process.env.NODE_ENV === 'test') {
      this.templatesRendered.push(rendered);
    }

    return rendered;
  }

  /**
   * Creates a prompt tracking object that will be sent along with Autoblocks events
   * to track which templates were used.
   */
  usage(): PromptTracking {
    const templates = Object.entries(this.templatesUsed).map(
      ([id, template]) => {
        return { id, template };
      },
    );

    return {
      id: this.trackingId,
      templates: templates,
    };
  }

  /**
   * Intended to be used with Jest snapshot testing.
   *
   * This will allow you to easily snapshot the rendered templates
   * so that your code reviews involve both the code changes and the
   * changes to the rendered templates.
   *
   * See https://jestjs.io/docs/snapshot-testing
   *
   * Example:
   *
   * const builder = promptManager.makeBuilder('my-tracking-id');
   *
   * const response = await openai.chat.completions.create({
   *   messages: [
   *     {
   *      role: 'system',
   *      content: builder.build('feature-a/system', {
   *        languageRequirement: builder.build('common/language', {
   *        language: 'Spanish',
   *      }),
   *     },
   *     {
   *      role: 'user',
   *      content: builder.build('feature-a/user', {
   *        name: 'Adam',
   *      }),
   *     },
   *   ],
   *   model: 'gpt-3.5-turbo',
   * });
   *
   * builder.snapshots().forEach((snapshot) => {
   *   expect(snapshot).toMatchSnapshot();
   * });
   */
  snapshots(): string[] {
    return this.templatesRendered;
  }
}
