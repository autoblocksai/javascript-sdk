import type { PromptTracking } from '../util';
import {
  __autogeneratedTemplatePathToTemplate,
  type __AutogeneratedTemplatePathToParameters,
} from './autogenerated';
import { replaceOptionalPlaceholders } from './util';

export class AutoblocksPromptBuilder {
  // An identifier for this prompt(s) building session.
  private readonly trackingId: string;

  // Keep track of which templates were used during the lifetime of the builder.
  private templatesUsed: Record<string, string>;

  // Keep track of the rendered templates for snapshot testing.
  private templatesRendered: string[];

  constructor(promptTrackingId: string) {
    this.trackingId = promptTrackingId;
    this.templatesUsed = {};
    this.templatesRendered = [];
  }

  build<Path extends keyof __AutogeneratedTemplatePathToParameters>(
    path: Path,
    params: __AutogeneratedTemplatePathToParameters[Path],
  ): string {
    const template = __autogeneratedTemplatePathToTemplate[path];

    if (!template) {
      throw new Error(`No template found for path ${path}`);
    }

    let rendered = template;

    const re = new RegExp(`\{\{\s*(\S+)[?]?\s*\}\}`, 'g');
    Object.entries(params).forEach(([key, value]) => {
      rendered = rendered.replace(re, (match, p1) => {
        if (p1 === key) {
          return `${value}`;
        }
        return match;
      });
    });
    rendered = rendered.trim();

    // Record that the template was used
    this.templatesUsed[path] = template;

    // Record the rendered template in test environments
    if (process.env.NODE_ENV === 'test') {
      this.templatesRendered.push(rendered);
    }

    return rendered;
  }

  /**
   * Creates a prompt tracking object that will be sent along with Autoblocks events
   * to track which templates were used.
   */
  usage(): PromptTracking {
    const templates = Object.entries(this.templatesUsed).map(
      ([id, template]) => {
        return { id, template };
      },
    );

    return {
      id: this.trackingId,
      templates: templates,
    };
  }

  /**
   * Intended to be used with Jest snapshot testing.
   *
   * This will allow you to easily snapshot the rendered templates
   * so that your code reviews involve both the code changes and the
   * changes to the rendered templates.
   *
   * See https://jestjs.io/docs/snapshot-testing
   *
   * Example:
   *
   * const builder = promptManager.makeBuilder('my-tracking-id');
   *
   * const response = await openai.chat.completions.create({
   *   messages: [
   *     {
   *      role: 'system',
   *      content: builder.build('feature-a/system', {
   *        languageRequirement: builder.build('common/language', {
   *        language: 'Spanish',
   *      }),
   *     },
   *     {
   *      role: 'user',
   *      content: builder.build('feature-a/user', {
   *        name: 'Adam',
   *      }),
   *     },
   *   ],
   *   model: 'gpt-3.5-turbo',
   * });
   *
   * builder.snapshots().forEach((snapshot) => {
   *   expect(snapshot).toMatchSnapshot();
   * });
   */
  snapshots(): string[] {
    return this.templatesRendered;
  }
}
