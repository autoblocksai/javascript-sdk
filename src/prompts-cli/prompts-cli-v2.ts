import fs from 'fs/promises';
import { readEnv, AutoblocksEnvVar } from '../util';
import { getAllPromptsFromV2API } from './v2/api';
import { autogenerationConfigsV2 } from './v2/config';
import { determineStartAndEndIdx, makeCommentsFor } from './v2/utils';
import { ParsedPromptV2 } from './v2/types';

export async function handleConfigV2(args: {
  config: (typeof autogenerationConfigsV2)[0];
  prompts: ParsedPromptV2[];
}): Promise<void> {
  const { startComment, endComment } = makeCommentsFor(args.config.symbolName);
  const generated = args.config.generate({
    symbolName: args.config.symbolName,
    prompts: args.prompts,
  });

  const contentToInsert = `${startComment}\n${generated}\n${endComment}\n`;

  await Promise.all(
    args.config.filesToModify.map(async (filename) => {
      const filepath = `${__dirname}/${filename}`;

      let content: string;

      try {
        await fs.access(filepath);
        content = await fs.readFile(filepath, 'utf-8');
      } catch (error) {
        console.warn(`Error accessing file: ${error}`);

        // File doesn't exist, create it with empty interface
        content = `// This file is auto-generated by the prompts-cli
// DO NOT EDIT MANUALLY

interface ${args.config.symbolName} {}\n`;
        await fs.writeFile(filepath, content);
      }

      // Remove any existing APP_NAME_TO_ID declarations that might cause conflicts
      const appNameToIdPatterns = [
        /declare const APP_NAME_TO_ID: Record<string, string>;/g,
      ];

      // Apply each removal pattern if content exists
      if (content) {
        for (const pattern of appNameToIdPatterns) {
          content = content.replace(pattern, '');
        }
      }

      try {
        const { startIdx, endIdx } = determineStartAndEndIdx({
          symbolName: args.config.symbolName,
          symbolType: args.config.symbolType,
          startComment,
          endComment,
          content,
        });

        const newContent =
          content.slice(0, startIdx) + contentToInsert + content.slice(endIdx);
        await fs.writeFile(filepath, newContent);
      } catch (error) {
        console.warn(`Error determining start and end indexes: ${error}`);
        // If we can't find the interface, append it to the file
        await fs.writeFile(filepath, content + '\n' + contentToInsert);
      }
    }),
  );
}

export async function runV2(): Promise<void> {
  const startTime = performance.now();

  const apiKey = readEnv(AutoblocksEnvVar.AUTOBLOCKS_V2_API_KEY);

  if (!apiKey) {
    throw new Error(
      `You must set the ${AutoblocksEnvVar.AUTOBLOCKS_V2_API_KEY} environment variable to generate types for your prompts.`,
    );
  }

  console.log('Fetching prompts from V2 API...');
  // Fetch prompts from V2 API
  const promptsV2 = await getAllPromptsFromV2API({ apiKey });
  console.log(`Found ${promptsV2.length} prompts in V2 API`);

  if (promptsV2.length === 0) {
    console.warn('No prompts found in V2 API. Check your API key permissions.');
    return;
  }

  // Create app mapping using same logic as APP_NAME_TO_ID
  const appNameToId: Record<string, string> = {};

  promptsV2.forEach((prompt) => {
    appNameToId[prompt.appName] = prompt.appId;
  });

  // Write to app-mapping.json
  const appMappingPath = `${__dirname}/../prompts/app-mapping.json`;

  await fs.writeFile(
    appMappingPath,
    JSON.stringify(appNameToId, null, 2),
    'utf-8',
  );

  console.log(`Generated app mapping at ${appMappingPath}`);

  // Process V2 prompts
  for (const config of autogenerationConfigsV2) {
    await handleConfigV2({
      config,
      prompts: promptsV2,
    });
  }

  const duration = performance.now() - startTime;
  console.log(
    `âœ“ Compiled in ${duration.toFixed(2)}ms (${promptsV2.length} prompts from V2 API)`,
  );
}
