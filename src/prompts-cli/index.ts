import fs from 'fs/promises';

type Templates = Record<string, string>;
type TemplatePlaceholders = Record<string, string[]>;

interface AutogenerationConfig {
  // The name of the symbol we're autogenerating.
  symbolName: string;
  // The appearance of the symbol before the autogeneration script has run for the first time.
  symbolAppearanceBeforeAutogeneration: string;
  // The files where the symbol lives and where we'll insert the autogenerated content.
  filesToModify: string[];
  // The function that generates the content to insert.
  generate: (args: {
    templates: Templates;
    templatePlaceholders: TemplatePlaceholders;
  }) => string;
}

// The directory this package will be in once someone installs it.
// We use this to make sure we ignore our own files when searching
// for the templates directory.
const THIS_PACKAGE_DIRECTORY_NAME = 'node_modules/@autoblocks/client';

// We autogenerate these based on the templates directory.
// See src/prompts/autogenerated.ts.

// This interface maps the name of the template to an interface of the placeholders
// that template expects.
const AUTOGENERATED_INTERFACE_NAME =
  '__Autogenerated__TemplatePathToParameters';

// This is for templates with no placeholders. This will allow us to add an overload
// to the build() method that takes no parameters.
const AUTOGENERATED_INTERFACE_NAME_FOR_NO_PLACEHOLDERS =
  '__Autogenerated__TemplatePathWithNoPlaceholders';

// This is the name of the JavaScript variable that will contain the actual
// templates.
const AUTOGENERATED_VARIABLE_NAME = '__autogenerated__templatePathToTemplate';

const autogenerationConfigs: AutogenerationConfig[] = [
  {
    symbolName: AUTOGENERATED_INTERFACE_NAME,
    symbolAppearanceBeforeAutogeneration: `interface ${AUTOGENERATED_INTERFACE_NAME} {\n}`,
    filesToModify: ['../prompts/index.d.ts', '../prompts/index.d.mts'],
    generate: (args) => {
      let generated = `interface ${AUTOGENERATED_INTERFACE_NAME} {`;

      Object.entries(args.templatePlaceholders)
        .filter(([, placeholders]) => placeholders.length > 0)
        .sort(([pathA], [pathB]) => (pathA < pathB ? -1 : 1))
        .forEach(([path, placeholders]) => {
          generated += `\n  '${path}': {`;
          placeholders.map((placeholder) => {
            generated += `\n    '${placeholder}': string;`;
          });
          generated += '\n  };';
        });

      generated += `\n}`;

      return generated;
    },
  },
  {
    symbolName: AUTOGENERATED_INTERFACE_NAME_FOR_NO_PLACEHOLDERS,
    symbolAppearanceBeforeAutogeneration: `interface ${AUTOGENERATED_INTERFACE_NAME_FOR_NO_PLACEHOLDERS} {\n}`,
    filesToModify: ['../prompts/index.d.ts', '../prompts/index.d.mts'],
    generate: (args) => {
      let generated = `interface ${AUTOGENERATED_INTERFACE_NAME_FOR_NO_PLACEHOLDERS} {`;

      Object.entries(args.templatePlaceholders)
        .filter(([, placeholders]) => placeholders.length === 0)
        .sort(([pathA], [pathB]) => (pathA < pathB ? -1 : 1))
        .forEach(([path]) => {
          generated += `\n  '${path}': true;`;
        });

      generated += `\n}`;

      return generated;
    },
  },
  {
    symbolName: AUTOGENERATED_VARIABLE_NAME,
    symbolAppearanceBeforeAutogeneration: `var ${AUTOGENERATED_VARIABLE_NAME} = {};`,
    filesToModify: ['../prompts/index.js', '../prompts/index.mjs'],
    generate: (args) => {
      let generated = `var ${AUTOGENERATED_VARIABLE_NAME} = {`;

      Object.entries(args.templates)
        .sort(([pathA], [pathB]) => (pathA < pathB ? -1 : 1))
        .forEach(([path, template]) => {
          generated += `\n  '${path}': \`${template}\`,`;
        });

      generated += `\n}`;

      return generated;
    },
  },
];

export class PromptsCLI {
  private templates: Templates = {};
  private templatePlaceholders: TemplatePlaceholders = {};

  /**
   * These comments are added by our autogeneration script before
   * and after the autogenerated segment so that we can find
   * the start and end indexes of the segment in the file later
   * on subsequent runs.
   *
   * This also helps us determine if the autogeneration script has run
   * at all.
   */
  private makeCommentsFor(name: string): {
    startComment: string;
    endComment: string;
  } {
    return {
      startComment: `// ${name} start`,
      endComment: `// ${name} end`,
    };
  }

  /**
   * Determine the start and end indexes of the autogenerated segment.
   */
  private determineStartAndEndIdx(args: {
    symbolAppearanceBeforeAutogeneration: string;
    startComment: string;
    endComment: string;
    content: string;
  }): {
    startIdx: number;
    endIdx: number;
  } {
    const startCommentIdx = args.content.indexOf(args.startComment);
    const endCommentIdx = args.content.indexOf(args.endComment);
    if (startCommentIdx !== -1 && endCommentIdx !== -1) {
      // The autogeneration CLI has been run before.
      return {
        startIdx: startCommentIdx,
        endIdx: endCommentIdx + args.endComment.length,
      };
    }

    // The autogeneration CLI is being run for the first time.
    // Search for what the symbol looks like before autogenration;
    // that will be the start and end indexes of where we will insert
    // the autogenerated content.
    const firstTimeAppearance = args.content.indexOf(
      args.symbolAppearanceBeforeAutogeneration,
    );
    if (firstTimeAppearance !== -1) {
      return {
        startIdx: firstTimeAppearance,
        endIdx:
          firstTimeAppearance +
          args.symbolAppearanceBeforeAutogeneration.length,
      };
    }

    throw new Error(
      `Couldn't find ${args.symbolAppearanceBeforeAutogeneration} in ${args.content}`,
    );
  }

  /**
   * Find nearest package.json file that has an autoblocks.templatesDirectory field.
   */
  private async findTemplatesDirectoryFromNearestPackageJson(): Promise<string> {
    let currentDir = __dirname;

    while (currentDir !== '/') {
      if (!currentDir.includes(THIS_PACKAGE_DIRECTORY_NAME)) {
        let content: string | undefined = undefined;

        try {
          content = await fs.readFile(`${currentDir}/package.json`, 'utf-8');
        } catch {
          // File does not exist, continue to the parent directory
        }

        if (content) {
          const packageObj: { autoblocks?: { templatesDirectory?: string } } =
            JSON.parse(content);
          const templatesDirectory = packageObj.autoblocks?.templatesDirectory;
          if (templatesDirectory) {
            if (templatesDirectory.startsWith('/')) {
              // Absolute path
              return templatesDirectory;
            } else if (templatesDirectory.startsWith('./')) {
              // Relative path
              return `${currentDir}/${templatesDirectory.slice(2)}`;
            } else {
              // Relative path
              return `${currentDir}/${templatesDirectory}`;
            }
          }
        }
      }

      currentDir = currentDir.slice(0, currentDir.lastIndexOf('/'));
    }

    throw new Error(
      "Couldn't find autoblocks.templatesDirectory in a package.json file.",
    );
  }

  /**
   * Walk the directory recursively and add all templates to the templates object.
   */
  private async walkDirectory(args: {
    directoryName: string;
    pathToTemplatesDirectory: string;
  }): Promise<void> {
    const dirs = await fs.readdir(args.directoryName);

    await Promise.all(
      dirs.map(async (dir) => {
        const path = `${args.directoryName}/${dir}`;
        const stat = await fs.stat(path);
        if (stat.isDirectory()) {
          await this.walkDirectory({
            directoryName: path,
            pathToTemplatesDirectory: args.pathToTemplatesDirectory,
          });
        } else {
          // Get the path to the template relative to the templates/ directory and remove the
          // leading slash.
          const relativePath = path
            .replace(args.pathToTemplatesDirectory, '')
            .slice(1);

          const fileContent = await fs.readFile(path, 'utf-8');

          this.templates[relativePath] = fileContent;

          // Find all placeholder names in the template. They look like: {{ placeholder }}
          // They can have arbitrary whitespace between the leading {{ and trailing }},
          // so e.g. {{placeholder}} is also valid.
          const placeholders = fileContent.match(/\{\{\s*\S+\s*\}\}/g);

          // Get the placeholder names, e.g. `placeholder` from `{{ placeholder }}`
          // by removing the `{{` and `}}` on each side and trimming off the whitespace.
          const placeholderNames = (placeholders ?? []).map((placeholder) => {
            return placeholder.slice(2, -2).trim();
          });
          const uniquePlaceholderNames = Array.from(new Set(placeholderNames));

          console.log(`Found template ${relativePath}`);
          console.log(`  Placeholders: ${uniquePlaceholderNames.join(', ')}`);

          this.templatePlaceholders[relativePath] = uniquePlaceholderNames;
        }
      }),
    );
  }

  private async handleConfig(config: AutogenerationConfig): Promise<void> {
    const { startComment, endComment } = this.makeCommentsFor(
      config.symbolName,
    );
    const generated = config.generate({
      templates: this.templates,
      templatePlaceholders: this.templatePlaceholders,
    });

    const contentToInsert = `${startComment}\n${generated}\n${endComment}\n`;

    await Promise.all(
      config.filesToModify.map(async (filename) => {
        const filepath = `${__dirname}/${filename}`;
        const content = await fs.readFile(filepath, 'utf-8');
        const { startIdx, endIdx } = this.determineStartAndEndIdx({
          symbolAppearanceBeforeAutogeneration:
            config.symbolAppearanceBeforeAutogeneration,
          startComment,
          endComment,
          content,
        });
        const newContent =
          content.slice(0, startIdx) + contentToInsert + content.slice(endIdx);
        await fs.writeFile(filepath, newContent);
      }),
    );
  }

  async run(): Promise<void> {
    const templatesDirectory =
      await this.findTemplatesDirectoryFromNearestPackageJson();

    console.log(`Found templates directory: ${templatesDirectory}`);
    console.log('Generating types...');

    await this.walkDirectory({
      directoryName: templatesDirectory,
      pathToTemplatesDirectory: templatesDirectory,
    });

    // This needs to happen sequentially so we don't have multiple
    // configs trying to modify the same files.
    for (const config of autogenerationConfigs) {
      await this.handleConfig(config);
    }
  }
}
