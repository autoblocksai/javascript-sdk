import fs from 'fs/promises';
import {
  readEnv,
  AutoblocksEnvVar,
  RevisionSpecialVersionsEnum,
  AUTOBLOCKS_HEADERS,
  API_ENDPOINT,
  makeCommentsFor,
  determineStartAndEndIdx,
} from '../util';
import { makeTypeScriptTypeFromValue, parseTemplate, sortBy } from './util';
import type { ParsedPrompt } from './types';
import { SymbolType } from '../types';

export { runV2 } from './prompts-cli-v2';

interface AutogenerationConfig {
  // The name of the symbol we're autogenerating.
  symbolName: string;
  // Whether the symbol is a TS interface or a JS variable
  symbolType: SymbolType;
  // The files where the symbol lives and where we'll insert the autogenerated content.
  filesToModify: string[];
  // The function that generates the content to insert.
  generate: (args: { symbolName: string; prompts: ParsedPrompt[] }) => string;
}

export const autogenerationConfigs: AutogenerationConfig[] = [
  {
    symbolName: '__Autogenerated__PromptsTypes',
    symbolType: 'interface',
    filesToModify: ['../prompts/index.d.ts', '../prompts/index.d.mts'],
    generate: (args) => {
      // Make map of prompt ID -> major version -> { templates, params, tools, minorVersions }
      let generated = `interface ${args.symbolName} {`;

      args.prompts.forEach((prompt) => {
        generated += `\n  '${prompt.id}': {`;

        // Use `any` for everything when version is set to `undeployed`.
        // Allows the user to use any template or model params while
        // working with an undeployed prompt in the UI
        generated += `\n    '${RevisionSpecialVersionsEnum.DANGEROUSLY_USE_UNDEPLOYED}': {`;
        generated += `\n      templates: any;`;
        generated += `\n      params: any;`;
        generated += `\n      tools: any;`;
        generated += `\n      minorVersions: any;`;
        generated += `\n    };`;

        prompt.majorVersions.forEach((version) => {
          generated += `\n    '${version.majorVersion}': {`;

          generated += `\n      templates: {`;
          version.templates.forEach((template) => {
            if (template.placeholders.length > 0) {
              generated += `\n        '${template.id}': {`;
              template.placeholders.forEach((placeholder) => {
                if (placeholder.endsWith('?')) {
                  generated += `\n          '${placeholder.slice(
                    0,
                    -1,
                  )}'?: string;`;
                } else {
                  generated += `\n          '${placeholder}': string;`;
                }
              });
              generated += '\n        };';
            } else {
              generated += `\n        '${template.id}': Record<PropertyKey, never>;`;
            }
          });

          generated += '\n      };';

          if (version.params) {
            generated += `\n      params: {`;
            sortBy(Object.keys(version.params), (k) => k).forEach((key) => {
              const val = version.params ? version.params[key] : undefined;
              const valType = makeTypeScriptTypeFromValue(val);
              if (!valType) {
                return;
              }
              generated += `\n        '${key}': ${valType};`;
            });
            generated += '\n      };';
          } else {
            generated += '\n      params: never;';
          }

          if (version.tools.length > 0) {
            generated += `\n      tools: {`;
            version.tools.forEach((tool) => {
              if (tool.placeholders.length > 0) {
                generated += `\n        '${tool.name}': {`;
                tool.placeholders.forEach((placeholder) => {
                  if (placeholder.endsWith('?')) {
                    generated += `\n          '${placeholder.slice(
                      0,
                      -1,
                    )}'?: string;`;
                  } else {
                    generated += `\n          '${placeholder}': string;`;
                  }
                });
                generated += '\n        };';
              } else {
                generated += `\n        '${tool.name}': Record<PropertyKey, never>;`;
              }
            });
            generated += '\n      };';
          } else {
            generated += '\n      tools: never;';
          }

          // Add type for minor versions
          generated += `\n      minorVersions: '${[
            ...version.minorVersions,
            RevisionSpecialVersionsEnum.LATEST,
          ].join(`' | '`)}';`;

          generated += '\n    };';
        });

        generated += '\n  };';
      });

      return generated + `\n}`;
    },
  },
];

async function getAllPromptsFromAPI(args: {
  apiKey: string;
}): Promise<ParsedPrompt[]> {
  const resp = await fetch(`${API_ENDPOINT}/prompts/types`, {
    method: 'GET',
    headers: {
      ...AUTOBLOCKS_HEADERS,
      Authorization: `Bearer ${args.apiKey}`,
    },
  });

  if (!resp.ok) {
    throw new Error(
      `Failed to fetch from V1 API: ${resp.status} ${resp.statusText}`,
    );
  }

  const data = await resp.json();
  return parseAndSortPrompts(data);
}

/**
 * Sorts and parses the placeholders out of the prompts retrieved from the API.
 */
export function parseAndSortPrompts(
  promptTypes: {
    id: string;
    majorVersions: {
      majorVersion: string;
      minorVersions: string[];
      templates: {
        id: string;
        template: string;
      }[];
      params?: { params: Record<string, unknown> };
      toolsParams: { name: string; params: string[] }[];
    }[];
  }[],
): ParsedPrompt[] {
  return sortBy(
    promptTypes.map((prompt) => {
      return {
        id: prompt.id,
        majorVersions: prompt.majorVersions.map((version) => {
          return {
            majorVersion: version.majorVersion,
            minorVersions: version.minorVersions,
            templates: sortBy(
              version.templates.map((template) => {
                return parseTemplate({
                  id: template.id,
                  content: template.template,
                });
              }),
              (t) => t.id,
            ),
            params: version.params?.params,
            tools: version.toolsParams.map((tool) => ({
              name: tool.name,
              placeholders: tool.params,
            })),
          };
        }),
      };
    }),
    (p) => p.id,
  );
}

async function handleConfig(args: {
  config: AutogenerationConfig;
  prompts: ParsedPrompt[];
}): Promise<void> {
  const { startComment, endComment } = makeCommentsFor(args.config.symbolName);
  const generated = args.config.generate({
    symbolName: args.config.symbolName,
    prompts: args.prompts,
  });

  const contentToInsert = `${startComment}\n${generated}\n${endComment}\n`;

  await Promise.all(
    args.config.filesToModify.map(async (filename) => {
      const filepath = `${__dirname}/${filename}`;
      const content = await fs.readFile(filepath, 'utf-8');
      const { startIdx, endIdx } = determineStartAndEndIdx({
        symbolName: args.config.symbolName,
        symbolType: args.config.symbolType,
        startComment,
        endComment,
        content,
      });
      const newContent =
        content.slice(0, startIdx) + contentToInsert + content.slice(endIdx);
      await fs.writeFile(filepath, newContent);
    }),
  );
}

export async function run(): Promise<void> {
  const startTime = performance.now();

  const apiKey = readEnv(AutoblocksEnvVar.AUTOBLOCKS_API_KEY);

  if (!apiKey) {
    throw new Error(
      `You must set the ${AutoblocksEnvVar.AUTOBLOCKS_API_KEY} environment variable to generate types for your prompts.`,
    );
  }

  // Fetch prompts from V1 API
  const promptsV1 = await getAllPromptsFromAPI({ apiKey });

  if (promptsV1.length === 0) {
    console.warn('No prompts found in V1 API. Check your API key permissions.');
    return;
  }

  // Process V1 prompts
  for (const config of autogenerationConfigs) {
    await handleConfig({
      config,
      prompts: promptsV1,
    });
  }

  const duration = performance.now() - startTime;
  console.log(
    `âœ“ Compiled in ${duration.toFixed(2)}ms (${promptsV1.length} prompts from V1 API)`,
  );
}
