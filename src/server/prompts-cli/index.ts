import fs from 'fs/promises';
import { z } from 'zod';
import {
  readEnv,
  AutoblocksEnvVar,
  HeadlessPromptSpecialVersion,
  AUTOBLOCKS_HEADERS,
} from '../../common/util';
import {
  zHeadlessPromptSchema,
  type HeadlessPrompt,
} from '../../common/models';

interface ParsedTemplate {
  id: string;
  content: string;
  placeholders: string[];
}

interface ParsedLocalPrompt {
  id: string;
  templates: ParsedTemplate[];
}

interface ParsedHeadlessPrompt extends ParsedLocalPrompt {
  majorVersion: string;
  minorVersion: string;
  modelParams?: Record<string, unknown>;
}

type SymbolType = 'interface' | 'variable';

interface AutogenerationConfig {
  // The name of the symbol we're autogenerating.
  symbolName: string;
  // Whether the symbol is a TS interface or a JS variable
  symbolType: SymbolType;
  // The files where the symbol lives and where we'll insert the autogenerated content.
  filesToModify: string[];
  // The function that generates the content to insert.
  generate: (args: {
    symbolName: string;
    localPrompts: ParsedLocalPrompt[];
    headlessPrompts: ParsedHeadlessPrompt[];
  }) => string;
}

export const autogenerationConfigs: AutogenerationConfig[] = [
  {
    symbolName: '__Autogenerated__HeadlessPromptsTypes',
    symbolType: 'interface',
    filesToModify: ['../prompts/index.d.ts', '../prompts/index.d.mts'],
    generate: (args) => {
      // Make map of prompt ID -> major version -> { templates, params, minorVersions }
      let generated = `interface ${args.symbolName} {`;

      Object.entries(
        groupBy(args.headlessPrompts, (prompt) => prompt.id),
      ).forEach(([promptId, promptsById]) => {
        generated += `\n  '${promptId}': {`;

        // Use `any` for everything when version is set to `undeployed`.
        // Allows the user to use any template or model params while
        // working with an undeployed prompt in the UI
        generated += `\n    '${HeadlessPromptSpecialVersion.DANGEROUSLY_USE_UNDEPLOYED}': {`;
        generated += `\n      templates: any;`;
        generated += `\n      modelParams: any;`;
        generated += `\n      minorVersions: any;`;
        generated += `\n    };`;

        Object.entries(
          groupBy(promptsById, (prompt) => prompt.majorVersion),
        ).forEach(([majorVersion, promptsByMajorVersion]) => {
          generated += `\n    '${majorVersion}': {`;

          // The templates and params should all be the same within a major version,
          // so just pick one to generate those types.
          const prompt = promptsByMajorVersion[0];

          if (!prompt) {
            return;
          }

          generated += `\n      templates: {`;
          prompt.templates.forEach((template) => {
            if (template.placeholders.length > 0) {
              generated += `\n        '${template.id}': {`;
              template.placeholders.forEach((placeholder) => {
                if (placeholder.endsWith('?')) {
                  generated += `\n          '${placeholder.slice(
                    0,
                    -1,
                  )}'?: string;`;
                } else {
                  generated += `\n          '${placeholder}': string;`;
                }
              });
              generated += '\n        };';
            } else {
              generated += `\n        '${template.id}': Record<PropertyKey, never>;`;
            }
          });

          generated += '\n      };';

          if (prompt.modelParams) {
            generated += `\n      modelParams: {`;
            sortBy(Object.keys(prompt.modelParams), (k) => k).forEach((key) => {
              const val = prompt.modelParams
                ? prompt.modelParams[key]
                : undefined;
              const valType = makeTypeScriptTypeFromValue(val);
              if (!valType) {
                return;
              }
              generated += `\n        '${key}': ${valType};`;
            });
            generated += '\n      };';
          } else {
            generated += '\n      modelParams: never;';
          }

          // Add type for minor versions
          const minorVersions = promptsByMajorVersion.map(
            (prompt) => prompt.minorVersion,
          );
          minorVersions.push(HeadlessPromptSpecialVersion.LATEST);

          generated += `\n      minorVersions: '${minorVersions
            .sort()
            .join(`' | '`)}';`;

          generated += '\n    };';
        });

        generated += '\n  };';
      });

      return generated + `\n}`;
    },
  },
  {
    symbolName: '__Autogenerated__LocalPromptsTypes',
    symbolType: 'interface',
    filesToModify: ['../prompts/index.d.ts', '../prompts/index.d.mts'],
    generate: (args) => {
      // Make map of prompt ID -> template ID -> placeholder types
      let generated = `interface ${args.symbolName} {`;

      args.localPrompts.forEach((prompt) => {
        generated += `\n  '${prompt.id}': {`;

        prompt.templates.forEach((template) => {
          if (template.placeholders.length > 0) {
            generated += `\n    '${template.id}': {`;
            template.placeholders.forEach((placeholder) => {
              if (placeholder.endsWith('?')) {
                generated += `\n      '${placeholder.slice(0, -1)}'?: string;`;
              } else {
                generated += `\n      '${placeholder}': string;`;
              }
            });
            generated += '\n    };';
          } else {
            generated += `\n    '${template.id}': Record<PropertyKey, never>;`;
          }
        });
        generated += '\n  };';
      });

      return generated + `\n}`;
    },
  },
  {
    symbolName: '__autogenerated__localPrompts',
    symbolType: 'variable',
    filesToModify: ['../prompts/index.js', '../prompts/index.mjs'],
    generate: (args) => {
      let generated = `var ${args.symbolName} = {`;

      args.localPrompts.forEach((prompt) => {
        generated += `\n  '${prompt.id}': {`;

        prompt.templates.forEach((template) => {
          generated += `\n    '${template.id}': \`${template.content}\`,`;
        });

        generated += '\n  },';
      });

      return generated + `\n};`;
    },
  },
];

/**
 * This is not exhaustive but should handle all of the possible types
 * for the model params.
 */
function makeTypeScriptTypeFromValue(val: unknown): string | undefined {
  if (typeof val === 'string') {
    return 'string';
  } else if (typeof val === 'number') {
    return 'number';
  } else if (typeof val === 'boolean') {
    return 'boolean';
  } else if (Array.isArray(val) && val.length > 0) {
    const item = val[0];
    return `Array<${makeTypeScriptTypeFromValue(item)}>`;
  }

  return undefined;
}

function groupBy<T, V extends string | number | symbol>(
  array: T[],
  getVal: (item: T) => V,
): Record<V, T[]> {
  return array.reduce(
    (accumulator, currentValue) => {
      const key = getVal(currentValue);
      if (!accumulator[key]) {
        accumulator[key] = [];
      }
      accumulator[key].push(currentValue);
      return accumulator;
    },
    {} as Record<V, T[]>,
  );
}

function sortBy<T, V extends string | number>(
  array: T[],
  getVal: (item: T) => V,
): T[] {
  return [...array].sort((a, b) => (getVal(a) < getVal(b) ? -1 : 1));
}

/**
 * These comments are added by our autogeneration script before
 * and after the autogenerated segment so that we can find
 * the start and end indexes of the segment in the file later
 * on subsequent runs.
 */
function makeCommentsFor(name: string): {
  startComment: string;
  endComment: string;
} {
  return {
    startComment: `// ${name} start`,
    endComment: `// ${name} end`,
  };
}

/**
 * Determine the start and end indexes of the autogenerated segment.
 */
function determineStartAndEndIdx(args: {
  symbolName: string;
  symbolType: SymbolType;
  startComment: string;
  endComment: string;
  content: string;
}): {
  startIdx: number;
  endIdx: number;
} {
  const startCommentIdx = args.content.indexOf(args.startComment);
  const endCommentIdx = args.content.indexOf(args.endComment);
  if (startCommentIdx !== -1 && endCommentIdx !== -1) {
    // The autogeneration CLI has been run before.
    return {
      startIdx: startCommentIdx,
      endIdx: endCommentIdx + args.endComment.length,
    };
  }

  // The autogeneration CLI is being run for the first time.
  // Search for what the symbol looks like before autogeneration;
  // that will be the start and end indexes of where we will insert
  // the autogenerated content.
  const symbolAppearanceBeforeAutogeneration =
    args.symbolType === 'interface'
      ? `interface ${args.symbolName} {\n}`
      : `var ${args.symbolName} = {};`;
  const firstTimeAppearance = args.content.indexOf(
    symbolAppearanceBeforeAutogeneration,
  );
  if (firstTimeAppearance !== -1) {
    return {
      startIdx: firstTimeAppearance,
      endIdx: firstTimeAppearance + symbolAppearanceBeforeAutogeneration.length,
    };
  }

  throw new Error(
    `Couldn't find ${symbolAppearanceBeforeAutogeneration} in ${args.content}`,
  );
}

/**
 * Find nearest package.json file that has an autoblocks.promptsDirectory field.
 * Only relevant for local prompts that are stored in files.
 */
async function findPromptsDirectoryFromNearestPackageJson(): Promise<
  string | undefined
> {
  let currentDir = __dirname;

  while (currentDir) {
    let content: string | undefined = undefined;

    try {
      content = await fs.readFile(`${currentDir}/package.json`, 'utf-8');
    } catch {
      // File does not exist, continue to the parent directory
    }

    if (content) {
      const packageObj: {
        name: string;
        autoblocks?: { promptsDirectory?: string };
      } = JSON.parse(content);
      const promptsDirectory = packageObj.autoblocks?.promptsDirectory;
      if (promptsDirectory) {
        if (promptsDirectory.startsWith('/')) {
          // Absolute path
          return promptsDirectory;
        } else if (promptsDirectory.startsWith('./')) {
          // Relative path
          return `${currentDir}/${promptsDirectory.slice(2)}`;
        } else {
          // Relative path
          return `${currentDir}/${promptsDirectory}`;
        }
      }
    }

    const lastSlashIdx = currentDir.lastIndexOf('/');
    if (lastSlashIdx === 0) {
      if (currentDir === '/') {
        // We've reached the root directory.
        break;
      } else {
        // Current directory is something like /Users, so we want the next
        // iteration to be /.
        currentDir = '/';
      }
    } else {
      // Current directory is something like /Users/nicole, so we want
      // the next iteration to be /Users.
      currentDir = currentDir.slice(0, lastSlashIdx);
    }
  }

  return undefined;
}

function parseTemplate(args: { id: string; content: string }): ParsedTemplate {
  // Find all placeholder names in the template. They look like: {{ placeholder }}
  // They can have arbitrary whitespace between the leading {{ and trailing }},
  // so e.g. {{placeholder}} is also valid.
  const placeholders = args.content.match(/\{\{\s*\S+\s*\}\}/g);

  // Get the placeholder names, e.g. `placeholder` from `{{ placeholder }}`
  // by removing the `{{` and `}}` on each side and trimming off the whitespace.
  const placeholderNames = (placeholders ?? []).map((placeholder) => {
    return placeholder.slice(2, -2).trim();
  });
  const uniquePlaceholderNames = Array.from(new Set(placeholderNames)).sort();

  return {
    id: args.id,
    content: args.content,
    placeholders: uniquePlaceholderNames,
  };
}

async function getHeadlessPromptsFromAPI(args: {
  apiKey: string;
}): Promise<ParsedHeadlessPrompt[]> {
  const resp = await fetch(`https://api.autoblocks.ai/prompts`, {
    method: 'GET',
    headers: {
      ...AUTOBLOCKS_HEADERS,
      Authorization: `Bearer ${args.apiKey}`,
    },
  });
  const data = await resp.json();
  const prompts = z.array(zHeadlessPromptSchema).parse(data);
  return parseAndSortHeadlessPrompts(prompts);
}

/**
 * Sorts and parses the placeholders out of the headless prompts retrieved from the API.
 */
export function parseAndSortHeadlessPrompts(
  prompts: HeadlessPrompt[],
): ParsedHeadlessPrompt[] {
  return sortBy(
    prompts.map((prompt) => {
      return {
        id: prompt.id,
        majorVersion: prompt.majorVersion,
        minorVersion: prompt.minorVersion,
        modelParams: prompt.params?.params,
        templates: sortBy(
          prompt.templates.map((template) => {
            return parseTemplate({
              id: template.id,
              content: template.template,
            });
          }),
          (t) => t.id,
        ),
      };
    }),
    (p) => p.id,
  );
}

/**
 * Walk the prompts directory recursively and adds all found prompts to the prompts array.
 */
async function getLocalPromptsFromFiles(): Promise<ParsedLocalPrompt[]> {
  const prompts: ParsedLocalPrompt[] = [];

  async function findPromptsInDirectory(args: {
    directoryName: string;
    rootDirectoryName: string;
    level: number;
  }): Promise<void> {
    const dirs = await fs.readdir(args.directoryName);

    await Promise.all(
      dirs.map(async (dir) => {
        const path = `${args.directoryName}/${dir}`;
        const stat = await fs.stat(path);
        if (stat.isDirectory()) {
          await findPromptsInDirectory({
            directoryName: path,
            rootDirectoryName: args.rootDirectoryName,
            level: args.level + 1,
          });
        } else {
          const relativePathParts = path
            .replace(`${args.rootDirectoryName}/`, '')
            .split('/');

          // The topmost folders in the prompts directory make up the prompts' unique IDs
          const promptId = relativePathParts.shift();
          // The template ID is the remaining filepath after removing the prompt ID (the
          // topmost folder name)
          const templateId = relativePathParts.join('/');

          if (!promptId || !templateId || args.level === 0) {
            console.warn(
              `Ignoring file at ${path}; prompts should be organized by directory within ${args.rootDirectoryName}.`,
            );
            return;
          }

          const fileContent = await fs.readFile(path, 'utf-8');

          const template = parseTemplate({
            id: templateId,
            content: fileContent,
          });

          const existingPrompt = prompts.find((p) => p.id === promptId);
          if (existingPrompt) {
            existingPrompt.templates.push(template);
          } else {
            prompts.push({
              id: promptId,
              templates: [template],
            });
          }
        }
      }),
    );
  }

  const promptsDirectory = await findPromptsDirectoryFromNearestPackageJson();

  if (promptsDirectory) {
    await findPromptsInDirectory({
      directoryName: promptsDirectory,
      rootDirectoryName: promptsDirectory,
      level: 0,
    });
  }

  // No need to sort the templates within each prompt because they're already sorted
  // by the directory structure.
  return sortBy(prompts, (p) => p.id);
}

async function handleConfig(args: {
  config: AutogenerationConfig;
  localPrompts: ParsedLocalPrompt[];
  headlessPrompts: ParsedHeadlessPrompt[];
}): Promise<void> {
  const { startComment, endComment } = makeCommentsFor(args.config.symbolName);
  const generated = args.config.generate({
    symbolName: args.config.symbolName,
    localPrompts: args.localPrompts,
    headlessPrompts: args.headlessPrompts,
  });

  const contentToInsert = `${startComment}\n${generated}\n${endComment}\n`;

  await Promise.all(
    args.config.filesToModify.map(async (filename) => {
      const filepath = `${__dirname}/${filename}`;
      const content = await fs.readFile(filepath, 'utf-8');
      const { startIdx, endIdx } = determineStartAndEndIdx({
        symbolName: args.config.symbolName,
        symbolType: args.config.symbolType,
        startComment,
        endComment,
        content,
      });
      const newContent =
        content.slice(0, startIdx) + contentToInsert + content.slice(endIdx);
      await fs.writeFile(filepath, newContent);
    }),
  );
}

export async function run(): Promise<void> {
  const startTime = Date.now();

  const localPrompts = await getLocalPromptsFromFiles();

  const apiKey = readEnv(AutoblocksEnvVar.AUTOBLOCKS_API_KEY);
  let headlessPrompts: ParsedHeadlessPrompt[] = [];
  if (apiKey) {
    headlessPrompts = await getHeadlessPromptsFromAPI({ apiKey });
  }

  const numPrompts = localPrompts.length + headlessPrompts.length;
  if (numPrompts === 0) {
    console.log('No prompts found.');
    return;
  }

  // NOTE: Do not run in Promise.all, these can't run
  // concurrently because they modify the same files.
  for (const config of autogenerationConfigs) {
    await handleConfig({
      config,
      localPrompts,
      headlessPrompts,
    });
  }

  const duration = Date.now() - startTime;
  console.log(`✓ Compiled in ${duration}ms (${numPrompts} prompts)`);
}
